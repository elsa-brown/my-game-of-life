{"version":3,"sources":["webpack:///webpack/bootstrap d9d45a0b0080c63a8013","webpack:///./board.js"],"names":["GOL","width","height","interval","cells","setUpBoardEvents","onCellClick","cell","cellId","id","className","board","document","getElementById","addEventListener","evt","target","play","togglePlay","createAndShowBoard","main","createElement","appendChild","i","row","j","getCell","col","theCell","xCoord","yCoord","forEachCell","iteratorFunc","setNextState","nextBoardState","nextCellState","console","log","getNeighborhood","neighborIds","neighborId","push","countLiveNeighbors","liveNeighbors","map","forEach","neighbor","getNextState","neighborhood","step","Object","assign","clearInterval","setInterval"],"mappings":"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;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAWA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,O","file":"./public/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d9d45a0b0080c63a8013","let GOL = {\n\twidth: 30,\n\theight: 30,\n\tinterval: null,\n\tcells: {}\n}\n\n// set each cell to a volume level audio.volume=number btw 0.0 and 1.0\n// make the volume a number relative to the person's chosen number{?}\n// i wonder if there could be spatialization of the sound.... \n// each cell is a PannerNode that is turned on or off depending on the cell status\n\n\nlet setUpBoardEvents = () => {\n\t\tconst onCellClick = (cell) => {\n\t\t\tlet cellId = cell.id\n\t\t\tif (GOL.cells[cellId] === 'dormant') {\n\t\t\t\tGOL.cells[cellId] = 'alive';\n\t\t\t\tcell.className = 'alive';\n\t\t\t}\n\t\t\t// } else {\n\t\t\t// \tGOL.cells[cellId] = 'dead';\n\t\t\t// \tcell.className = 'dead';\n\t\t\t// }\n\t\t};\n\n\t\tlet board = document.getElementById('main');\n\t\tboard.addEventListener('mousedown', (evt) => {\n\t\t\t// console.log('mousedown target', evt.target, 'id', evt.target.id)\n\t\t\tlet cell = evt.target\n\t\t\tonCellClick(cell)\n\t\t})\n\t\tlet play = document.getElementById('button');\n\t\tplay.addEventListener('click', evt => togglePlay())\n\n}\n\nlet createAndShowBoard = () => {\n\t\t// const cells = new Array(this.height * this.width);\n\t\tconst main = document.getElementById('main');\n\t\tconst board = document.createElement('tbody');\n\t\tmain.appendChild(board);\n\n\t\tfor (let i = 0; i < GOL.width; i++) {\n\t\t\tlet row = document.createElement('tr');\n\t\t\trow.id = i\n\t\t\tboard.appendChild(row);\n\n\t\t\tfor (let j = 0; j < GOL.height; j++) {\n\t\t\t\tGOL.cells[`${i}-${j}`] = 'dormant'\n\t\t\t\tlet cell = document.createElement('td');\n\t\t\t\tcell.id = `${i}-${j}`\n\t\t\t\tcell.className = 'dormant'\n\t\t\t\trow.appendChild(cell);\n\t\t\t}\n\t\t}\n\t\tsetUpBoardEvents()\n\t\t// console.log('board', board)\n\t\t// console.log('cells', this.cells)\n}\n\nlet getCell = (row, col) => {\n\t\t// console.log('inside getCell', row, col)\n\t\tlet theCell = document.getElementById(`${col}-${row}`);\n\t\t// console.log('theCell', theCell)\n\t\tif (!theCell) return null\n\t\ttheCell.xCoord = col;\n\t\ttheCell.yCoord = row;\n\t\treturn theCell\n}\n\nlet forEachCell = (iteratorFunc) => {\n\t\t// console.log('inside forEachCell')\n\t\tfor (let col = 0; col < GOL.width; col++) {\n\t\t\tfor (let row = 0; row < GOL.height; row++) {\n\t\t\t\tlet theCell = getCell(row, col)\n\t\t\t\titeratorFunc(theCell, row, col)\n\t\t\t}\n\t\t}\n}\n\n// nextState is an object literal\nlet setNextState = (nextBoardState) => {\n\tfor (var cellId in nextBoardState) {\n\t\tlet nextCellState = nextBoardState[cellId]\n\t\tGOL.cells[cellId] = nextCellState\n\t\tlet cell = document.getElementById(cellId)\n\t\tcell.className = nextCellState\n\t}\n\t// for (var i = 0; i < nextState.length; i++) {\n\t// \tfor (var j = 0; j < nextState[i].length; j++) {\n\t// \t\tlet nextStatus = nextState[i][j] ? 'alive' : 'dead'\n\t// \t\tcells[`${i}-${j}`] = nextStatus\n\t// \t}\n\t// }\n\tconsole.log('newCells', GOL.cells)\n}\n\nlet getNeighborhood = (cell, row, col) => {\n\tlet neighborIds = [];\n\tfor (let i = col - 1; i <= col + 1; i++) {\n\t\tfor (let j = row - 1; j <= row + 1; j++) {\n\t\t\t// console.log('neighbor coords', i, j)\n\t\t\tif (i !== col || j !== row) {\n\t\t\t\tif (i > -1 && j > -1) {\n\t\t\t\t\tlet neighborId = i + '-' + j;\n\t\t\t\t\tif (neighborId) neighborIds.push(neighborId)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn neighborIds;\n}\n\nlet countLiveNeighbors = (neighborIds) => {\n\t// console.log('neighborIds', neighborIds)\n\tlet liveNeighbors = 0\n\tneighborIds.map(id => {\n\t\treturn document.getElementById(id)\n\t}).forEach(neighbor => {\n\t\tif (neighbor && neighbor.className === 'alive') liveNeighbors++\n\t})\n\t// console.log('liveNeighbors', liveNeighbors)\n\treturn liveNeighbors;\n}\n\nlet getNextState = (cell, row, col) => {\n\tlet neighborhood = getNeighborhood(cell, row, col);\n\t\t// console.log('Inside getNextState. cell is', cell)\n\n\t\t// console.log('neighbors', neighborIds)\n\t\tlet liveNeighbors = countLiveNeighbors(neighborhood);\n\t\t// console.log('cell: ', cell, 'liveNeighbors: ', liveNeighbors)\n\n\t\tif (cell.className === 'alive') {\n\t\t\tif (liveNeighbors < 2 || liveNeighbors > 3) return 'dead';\n\t\t\telse return 'alive';\n\t\t}\n\t\tif (cell.className === 'dead') {\n\t\t\tif (liveNeighbors === 3) return 'alive';\n\t\t\telse return 'dead';\n\t\t}\n\t\tif (cell.className === 'dormant') {\n\t\t\tif (liveNeighbors === 3) return 'alive';\n\t\t\telse return 'dormant';\n\t\t}\n\n\n\t\t//if (cell.className === 'alive' &&)\n\t\t// \t.map(el => {\n\t\t// \t\tconsole.log('el', el)\n\t\t// \t\tel.className === 'alive' ? 1 : 0\n\t\t// \t})\n\t\t// \t.reduce((sum, alive) => sum + alive, 0)\n\n\n}\n\nlet step = () => {\n\tlet nextBoardState = Object.assign({}, GOL.cells)\n\t\t// let nextBoardState = new Array(GOL.width).fill('')\n\t // \t\t.map(el => new Array(GOL.height).fill(''))\n\t\t// // console.log('nextBoardState', nextBoardState)\n\tforEachCell((cell, row, col) => {\n\t\tnextBoardState[`${col}-${row}`] = getNextState(cell, row, col)\n\t})\n\t\tconsole.log('nextBoardState', nextBoardState)\n\n\n\tsetNextState(nextBoardState);\n}\n\nlet togglePlay = () => {\n\t\tif (GOL.interval) {\n\t\t\tclearInterval(GOL.interval);\n\t\t\tGOL.interval = null\n\t\t} else {\n\t\t\tGOL.interval = setInterval(() => step(), 150)\n\t\t}\n}\n\n\t// randomize: function() {\n\t// \tlet nextBoardState = new Array(this.width).fill('')\n\t// \t\t.map(el => new Array(this.height).fill('')\n\t// \t\t\t.map(cell => Math.random() <= 0.5))\n\t// \t\tconsole.log('nextBoardState', nextBoardState)\n\n\t// \t\tthis.setNextState(nextBoardState)\n\t// }\n\ncreateAndShowBoard();\n\n// canvas\n// const gameDisplay = (width = 30, height = 30, cellSize = 18) => {\n// \tlet canvas = document.getElementById('canvas')\n// \tconst ctx = canvas.getContext && canvas.getContext('2d')\n// \tconst widthPx = width * cellSize\n// \tconst heightPx = height * cellSize\n// }\n\n// const drawGridLines = () => {\n// \t\tctx.lineWidth = 1;\n// \t\tctx.strokeStyle = \"rgb(255, 0, 0)\";\n// \t\tctx.beginPath();\n// \t\tfor (let i = 0; i <= width; i++) {\n// \t\t\tctx.moveTo(i * cellSize, 0);\n// \t\t\tctx.lineTo(i * cellSize, heightPx)\n// \t\t}\n// \t\tfor (let j = 0; j <= height; j++) {\n// \t\t\tctx.moveTo(j * cellSize, 0);\n// \t\t\tctx.lineTo(j * widthPx, j * cellSize)\n// \t\t}\n// \t\tctx.stroke();\n// \t}\n\n// gameDisplay();\n\n// const table = document.getElementById('board');\n\n// const Board = (width = 30, height = 30) => {\n// \tthis.width = width\n// \tthis.height = height\n// \tthis.cells = []\n// }\n\n\n// const populateBoard = (board) => {\n// \tfor (var i = 0; i < this.width; i++) {\n// \t\tfor (var j = 0; j < this.height; j++) {\n// \t\t\tlet theCell = new Cell(i, j);\n// \t\t\tthis.cells.push(theCell)\n// \t}\n// }\n\n// class Cell {\n// \tconstructor(xCoord, yCoord, state) {\n// \t\tthis.xCoord = xCoord;\n// \t\tthis.yCoord = yCoord;\n// \t\tthis.state = state || 'dormant'\n// \t}\n\n// \tgetX() {\n// \t\treturn this.xCoord;\n// \t}\n\n// \tgetY() {\n// \t\treturn this.xCoord;\n// \t}\n\n// \tgetState() {\n// \t\treturn this.state;\n// \t}\n\n// \tsetState(newState) {\n// \t\tthis.state = newState;\n// \t}\n\n// \tgetNeighborhood(board) {\n// \t\tlet x = this.xCoord;\n// \t\tlet y = this.yCoord;\n// \t\tlet width = board.width;\n// \t\tlet height = board.height;\n\n// \t\tlet left =  x === 0 ? (width - 1) : (x - 1);\n// \t\tlet right = x === width ? 0 : (x + 1);\n// \t\tlet top = y === height ? 0 : (y - 1);\n// \t\tlet bottom = y === 0 ? height : (y + 1);\t\n// \t}\n// }\n\n\n// \t// pulls our first two elements of array and names them row and col\n// \tindexFor([row, col]) {\n// \t\t// return undefined if out of bounds\n// \t\t// TODO: refactor to send to other side of board\n// \t\tif (row < 0 || row >= this.height) || col < 0 || col >= this.width) return\n// \t\treturn row * this.width + col\n// \t}\n\n// \tgetCoords(coords) {\n// \t\treturn this.cells[this.indexFor(coords)] || 0\n// \t}\n\n// \tset(coords, value) {\n// \t\tthis.cells[this.indexFor(coords)] = value;\n// \t}\n\n// \tcountlivingNeighbors(row, col) {\n// \t\t// Store each neighbor cell's coordinates in a variable. \n// \t\t// If a cell is at the board boundary, make a neighbor on the opposite side of the board\n// \t\tconst left = row - 1 < 0 ? (this.width - 1) : (row - 1);\n// \t\tconst right = row + 1 === this.width ? 0 : (x + 1);\n// \t\tconst top = col - 1 < 0 ? (this.height - 1) : (y - 1);\n// \t\tconst bottom = col + 1 === this.height ? 0 : (y + 1);\n\n// \t\tlet count = 0;\n\n// \t\tisAlive(cells[top][left]) count++;\n// \t\tisAlive(cells[top][col]) count++;\n// \t\tisAlive(cells[top][right]) count++;\n// \t\tisAlive(cells[row][left]) count++;\n// \t\tisAlive(cells[row][right]) count++;\n// \t\tisAlive(cells[bottom][left]) count++;\n// \t\tisAlive(cells[bottom][col]) count++;\n// \t\tisAlive(cells[bottom][right]) count++;\n\n\t\t\n// \t}\n\n// \ttoggle(coords) {\n// \t\tthis.set(coords, 1 - this.get(coords));\n// \t}\n// }\n\n// const isAlive(row, col) {\n// \tif (cells[row][col] === 'alive') return true;\n// \telse return false;\n// }\n\n// // iterator to apply to each cell\n// const conway = (isAlive, numLivingNeighbors) => {\n// \tif (isAlive) {\n// \t\treturn numLivingNeighbors === 2 || numLivingNeighbors === 3;\n// \t} else {\n// \t\treturn numLivingNeighbors === 3;\n// \t}\n// }\n\n// // compare current state to next state and update\n// const tick(presentState, nextState, rules=conway) {\n// \tfor (var i = 0; i < presentState.height; i++) {\n// \t\tfor (var j = 0; j< present.width; j++) {\n// \t\t\tconst shouldBeAlive = rules(present.get([i, j]), present.livingNeighbors([i, j]));\n// \t\t\tfuture.set([i, j], shouldBeAlive);\n// \t\t}\n// \t}\n// \treturn [nextState, presentState]\n// }\n\n\n\n\n\n\n\n\n\n\n// var GOL = {\n// \twidth: 30,\n// \theight: 30,\n// \tstepInterval: null,\n\n// \tcreateAndShowBoard: function() {\n// \t\tvar gameBoard = document.createElement(\"tbody\");\n\n// \t\tvar tablehtml = '';\n// \t\tfor (var h = 0; h < this.height; h++) {\n// \t\t\ttablehtml += `<tr id=\"row-${h}\">`\n// \t\t\tfor (var w = 0; w < this.width; w++) {\n// \t\t\t\ttablehtml += `<td data-status=\"dead\" id=\"${w}-${h}\"\"></td>`\n// \t\t\t}\n// \t\t\ttablehtml += `</tr>`\n// \t\t}\n// \t\tgameBoard.innerHTML = tablehtml;\n\n// \t\tdocument.getElementById(\"board\").appendChild(gameBoard);\n\n// \t\tthis.setUpBoardEvents();\n// \t},\n\n// \tgetCell: function(row, col) {\n// \t\tvar theCell = document.getElementById(`${col}-${row}`)\n// \t\tif(!theCell) return null\n// \t\ttheCell.col = col;\n// \t\ttheCell.row = row;\n// \t\treturn theCell;\n// \t},\n\n// \tforEachCell: function(iterator) {\n// \t\tfor (var col = 0; col < this.width; col++) {\n// \t\t\tfor (var row = 0; row < this.height; row++) {\n// \t\t\t\tvar theCell = this.getCell(row, col)\n// \t\t\t\titerator(theCell, row, col)\n// \t\t\t}\n// \t\t}\n// \t},\n\n// \tapplyState: function(nextState) {\n// \t\tthis.forEachCell((cell, row, col) => {\n// \t\t\tvar theStatus = nextState[col][row] ? 'alive' :\n// \t\t\tcell.className = theStatus;\n// \t\t\tcell.dataset.status = theStatus;\n// \t\t})\n// \t},\n\n// \tsetUpBoardEvents: function() {\n// \t\tvar onCellClick = function(e) {\n// \t\t\tif (this.dataset.status === 'dead') {\n// \t\t\t\tthis.className = 'alive';\n// \t\t\t\tthis.dataset.status = 'alive';\n// \t\t\t} else {\n// \t\t\t\tthis.className = 'dead';\n// \t\t\t\tthis.dataset.status = 'dead';\n// \t\t\t}\n// \t\t}\n\n// \t\twindow.board.addEventListener('click', e => onCellClick.call(e.target, e))\n// \t},\n\n// \tneighborhood: function(cell) {\n// \t\tvar neighbors = [];\n// \t\tfor (var col = cell.col - 1; col <= cell.col + 1; col++) {\n// \t\t\tfor (var row = cell.row - 1 ; row <= cell.row + 1; row++) {\n// \t\t\t\tif (row === cell.row && col === cell.col) continue\n// \t\t\t\tvar theCell = this.getCell(row, col)\n// \t\t\t\tif (theCell) neighbors.push(theCell)\n// \t\t\t}\n// \t\t}\n// \t\treturn neighbors\n// \t},\n\n// \tgetNextState: function(cell, row, col) {\n// \t\tvar livingNeighbors = this.neighborhood(cell)\n// \t\t\t.map(el => el.dataset.status === 'alive' ? 1 : 0)\n// \t\t\t.reduce((sum, alive) => sum + alive, 0)\n\n// \t\tif (cell.dataset.status === 'alive') {\n// \t\t\tif(livingNeighbors === 2 || livingNeighbors === 3) return true\n// \t\t\treturn false\n// \t\t}\n\n// \t\tif (livingNeighbors === 3) return true\n// \t\treturn false\n// \t},\n\n// \tstep: function() {\n// \t\tvar nextState = new Array(this.width).fill('').map(el => []);\n\n// \t\tthis.forEachCell((cell, row, col) =>\n// \t\t\tnextState[col][row] = this.getNextState(cell, row, col)\n// \t\t)\n\n// \t\tthis.applyState(nextState);\n// \t},\n\n// \ttogglePlay: function() {\n// \t\tif(this.interval) {\n// \t\t\tclearInterval(this.interval);\n// \t\t\tthis.interval = null\n// \t\t} else {\n// \t\t\tthis.interval = stepInterval(() => this.step(), 250)\n// \t\t}\n// \t},\n\n// \trandomize: function() {\n// \t\tvar nextState = new Array (this.width).fill('')\n// \t\t\t.map(el => new Array(this.height).fill('')\n// \t\t\t\t.map(cell => Math.random() <= 0.5)\n// \t\t\t)\n// \t\tthis.applyState(nextState)\n// \t},\n\n// \tclearBoard: function() {\n// \t\tthis.applyState(new Array(this.width).fill([]))\n// \t}\n// };\n\n// GOL.createAndShowBoard();\n\n// //TODO-function to make Live cell background images cycle thru a selection of gifs\n// // var getCellGif = function() {\n// // \tvar urlName = '';\n\n// // \tfor (var i = 0; i < 10; i++) {\n// // \t\turlName += `url(/public/life-${i})`\n// // \t}\n\n// // \tvar theCell = document.getElementById(\"td\");\n// // \tif (theCell.className === 'alive') {\n// // \t\ttheCell.innerHTML += `style: backround-image=\"${urlName}\"`\n// // \t}\n// // }\n\n\n\n\n// WEBPACK FOOTER //\n// ./board.js"],"sourceRoot":""}